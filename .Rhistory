rm(list = ls())
graphics.off()
getwd()
setwd("/Users/f007f8t/Documents/GitHub/Bayesian-Statistics-Class-Dartmouth")
list.of.packages <- c("BASS","lhs","caTools","Metrics","sensobol","plotrix",
"MASS","fields")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()
[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library(BASS)
library(lhs)
library(caTools)
library(Metrics)
library(sensobol)
library(plotrix)
library(MASS)
library(fields)
if(!dir.exists("figures")) dir.create("figures")
if(!dir.exists("figures/Workflow_example")) dir.create("figures/Workflow_example")
##############
set.seed(314)
################################################################################
# Define the toy example, here is a Quadratic function
Y <- function (theta1, theta2,t) {
return (theta1*(t^2)+theta2*t)}
################################################################################
# First assume we have a true model with known theta1 and theta2
True_theta1 <- -10
True_theta2 <- 2
################################################################################
# Create some observation data with random error from Gaussian distribution
N_obs <- 20
t_obs <- runif(N_obs, -5, 5)
sigma_obs <- 10
Observation<- c()
for (i in 1:length(t_obs)){
Observation[i] <- Y(True_theta1,True_theta2,t_obs[i])+rnorm(1,0,sigma_obs)
}
# Plot the real values vs the observation data
# Generate many true values
X <- seq(-5,5,by=0.01)
True_Y<- c()
for (i in 1:length(X)){
True_Y[i] <- Y(True_theta1,True_theta2,X[i])
# RMSE
rmse <- function(data,par){
return(sqrt(mean((data$y -Y(par[1],par[2],data$x))^2)))
}
# Find the parameters
fit_minRMSE <- optim(par=c(-2, 5), fn=rmse, data=data.frame(x=t_obs,
y=Observation))
# Predict y values at observational point
Fit_Y_obs<- c()
for (i in 1:length(t_obs)){
Fit_Y_obs[i] <- Y(fit_minRMSE$par[1],fit_minRMSE$par[2],t_obs[i])
}
# Generate the best fit curve on the obtained parameters
Fit_model_Y<- c()
for (i in 1:length(X)){
Fit_model_Y[i] <- Y(fit_minRMSE$par[1],fit_minRMSE$par[2],X[i])
}
# SSE
SSE_f <- function(data,par){
return(sum((data$y -Y(par[1],par[2],data$x))^2))
}
# Generate x,y,z for the contour plot
V.theta1 <- seq(-20,0,by=0.1)
V.theta2 <- seq(-20,20,by=0.2)
obs=data.frame(x=t_obs, y=Observation)
#generate a matrix of SSE values for different combinations of theta1 and theta2
V.SSE=mat.or.vec(length(V.theta1), length(V.theta2))
for(i in 1:length(V.theta1 )){
for (j in 1:length(V.theta2 )){
V.SSE[i,j] <- SSE_f(obs,c(V.theta1[i],V.theta2[j])) }}
V.theta1[101]
}
