plot(density(pctBelowThresholds[5e3:1e4,6]),main="",
xlab =paste0("P(Y<",thresholds[6],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:1e4,6]),col = "purple",lwd=3)
legend("topright", c("second 5k","first 10k"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
pdf(file="figures/Workflow_example/overlaid_densities_second5k_vs_first10k_p10.pdf")
plot(density(pctBelowThresholds[5e3:1e4,10]),main="",
xlab =paste0("P(Y<",thresholds[10],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:1e4,10]),col = "purple",lwd=3)
legend("topright", c("second 5k","first 10k"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
#does it look like 130k is enough steps?
pdf(file="figures/Workflow_example/overlaid_densities_half1_vs_all_p2.pdf")
plot(density(pctBelowThresholds[(NI/2+1):NI,2]),main="",
xlab =paste0("P(Y<",thresholds[2],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:NI,2]),col = "purple",lwd=3)
legend("topright", c("second half","all"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
pdf(file="figures/Workflow_example/overlaid_densities_half1_vs_all_p6.pdf")
plot(density(pctBelowThresholds[(NI/2+1):NI,6]),main="",
xlab =paste0("P(Y<",thresholds[6],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:NI,6]),col = "purple",lwd=3)
legend("topright", c("second half","all"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
pdf(file="figures/Workflow_example/overlaid_densities_half1_vs_all_p10.pdf")
plot(density(pctBelowThresholds[(NI/2+1):NI,10]),main="",
xlab =paste0("P(Y<",thresholds[10],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:NI,10]),col = "purple",lwd=3)
legend("topright", c("second half","all"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
#compare the rounded uncertainty bounds to the estimate for each significant figure
z <- half_width <- rep(NA, length(thresholds))
interval <- matrix(data = NA, nrow = length(thresholds), ncol = 2)
rownames(interval)<- thresholds
colnames(interval)<- c("lower_bound", "upper_bound")
for(i in 1:length(thresholds)){
z[i] <- (mean(pctBelowThresholds[,i]) - bm_est[i])/bm_se[i]
half_width[i] <- z[i] * bm_se[i ]
interval[i,1] <- bm_est[i] - half_width[i]
interval[i,2] <- bm_est[i] + half_width[i]
}
print(interval)
print(bm_est)
################################################################################
# Sobol Sensitivity Analysis on Peak value using the model
# "sensobol" package has a special design for a sobol matrix used for the analysis,
#     N here is the length of the matrix.
# The relationship between N and the sample size
# (when calculating up to 2nd order indices) is:
#     sample size = N*(d+2+d*(d-1)/2), where d is the number of parameters
# Note we take the nearest integer, hence the actual sample size is an
# approximation of the list of sample size we consider.
# parameter range
theta_1_max <- 0
theta_1_min <- -20
theta_2_max <- 20
theta_2_min <- -20
# peak estimation
peak <- function(parameter){
parameter[1]=parameter[1]*(theta_1_max-theta_1_min)+theta_1_min
parameter[2]=parameter[2]*(theta_2_max-theta_2_min)+theta_2_min
output=c()
tt<- seq(-4.5,4.5,0.1)
for(i in 1:length(tt)){
output[i]<-Y(parameter[1],parameter[2],tt[i])}
return(max(output)) }
# Function dimension
d <- 2
# Sample size
set.seed(314)
sample_size <-130000
N <- floor(sample_size/(d+2+d*(d-1)/2))
# The input matrix is generated by the Sobol sequence algorithm, distributed in (0, 1)
mat <- sobol_matrices(N = N, params = c("theta1","theta2"), order = "second")
X_sobol <- split(t(mat), rep(1:dim(mat)[1], each = d))
# The output matrix
Y_sobol <- sapply(X_sobol, peak)
# Sensitivity analysis
S <- sobol_indices(Y=Y_sobol,N=N,params = c("theta1","theta2"),
boot=TRUE,R=100,order="second")
# Convergence check: if all total-order sensitivity indices have a
# 95%CI width within 0.05, then it is converged
# If it was not converged increase sample size
Range <- S$results$high.ci[(d+1):(2*d)]-S$results$low.ci[(d+1):(2*d)]
if (all(Range<=0.05)){print("converged")}
# save the results
sobol_result <- matrix(c(S$results$original[3],S$results$original[4],
S$results$original[1],S$results$original[2],
S$results$original[5]),nrow=1,ncol=5,byrow = FALSE)
#################################################################################
# Sobol Sensitivity Analysis on Peak value using the BASS emulator
# Note: the Sobol analysis in this section directly uses the function in
# "BASS" package instead of sensobol package
# Choose sample size
sample_size <- 200
# Sample parameters using Latin hypercube sampling
samples <-  randomLHS(sample_size, 2)
# Define the train input and output
train_input <- samples
train_output <- c()
for(i in 1:sample_size){
train_output[i]<- peak(train_input[i,])}
#Fit the BASS emulator using the train data
#Users may set related parameters for the emulator structure and MCMC
# see more detailed information in bass() function documentation.
#The emulator consists of a series MCMC samples
bass_model <- bass(train_input, train_output,nmcmc = 10000)
# BASS analysis: calculate Sobol' indices based on the emulator
#Sensitivity indices for each MCMC sample will be calculated.
BASS_sensitivity <- sobol(bass_model)
# Convergence check: if all total-order sensitivity indices have a
# 95%CI width within 0.05, then it is converged
# If it was not converged increase sample size
Range_S_bass <-c()
Range_S_bass[1] <- 2*qt(0.975,length(BASS_sensitivity$S[,1]))*sd(BASS_sensitivity$S[,1])/sqrt(length(BASS_sensitivity$S[,1]))
Range_S_bass[2] <- 2*qt(0.975,length(BASS_sensitivity$S[,2]))*sd(BASS_sensitivity$S[,2])/sqrt(length(BASS_sensitivity$S[,2]))
Range_S_bass[3] <- 2*qt(0.975,length(BASS_sensitivity$T[,1]))*sd(BASS_sensitivity$T[,1])/sqrt(length(BASS_sensitivity$T[,1]))
Range_S_bass[4] <- 2*qt(0.975,length(BASS_sensitivity$T[,2]))*sd(BASS_sensitivity$T[,2])/sqrt(length(BASS_sensitivity$T[,2]))
Range_S_bass[5] <- 2*qt(0.975,length(BASS_sensitivity$S[,3]))*sd(BASS_sensitivity$S[,3])/sqrt(length(BASS_sensitivity$S[,3]))
if (all(Range_S_bass<=0.05)){print("converged")}
# Save the BASS mean sensitivity indices
BASS_result <- matrix(c(mean(BASS_sensitivity$T[ ,1]),
mean(BASS_sensitivity$T[ ,2]),mean(BASS_sensitivity$S[ ,1]),
mean(BASS_sensitivity$S[ ,2]),mean(BASS_sensitivity$S[ ,3]))
,nrow=1,ncol=5,byrow = FALSE)
# Plot and save the results from both analyses in a pdf file
Result_sensitivity <- matrix(c(sobol_result, BASS_result),nrow=2,ncol=5,byrow=TRUE)
colnames(Result_sensitivity ) <- c( "theta1-total-effect",
"theta2-total-effect","theta1-first-order",
"theta2-first-order", "theta1/theta2-second-order")
pdf(file="figures/Workflow_example/Sensitivity_Analysis.pdf",14,7)
par(fig=c(0,1,0.05,1),mar = c(3, 6, 2, 2))
barplot(Result_sensitivity, beside = TRUE,cex.axis=1,
cex.names=1,col=c("cornsilk4","orange"),ylim = c(0, 0.8),
las=1,ylab="Sobol Sensitivity")
legend("topright",
legend = c("Full model-130000 model runs","BASS-Emulation- 200 model runs"),
fill = c("cornsilk4", "orange"))
dev.off()
#what if you're interested in estimating a population proportion with mcmc?
#how should you evaluate the reliability of your estimate?
#does monte carlo standard error change with the proportion you're estimating?
#estimating a population proportion with mcmc
library(batchmeans)
#mcmc.chains<- mcmc.chains[-(1:30000),]
thresholds<- seq(-200,-300,by=-10)
bm_est<- rep(NA,length(thresholds))
bm_se<- rep(NA,length(thresholds))
p_hat<- rep(NA,length(thresholds))
sd_p_hat<- rep(NA,length(thresholds))
badXinds<- which(X< -4.7)
pctBelowThresholds<- matrix(NA,nrow=nrow(mcmc.chains),
ncol=length(thresholds))
for(th in 1:length(thresholds)){
Fit_model_MCMC<- mat.or.vec(nrow(mcmc.chains), length(badXinds))
for(j in 1:nrow(mcmc.chains)){
for (i in badXinds){
Fit_model_MCMC[j,i] <- Y(mcmc.chains[j,1],
mcmc.chains[j,2],X[i])+
rnorm(1,mean=0,sd=sigma_obs)
}
}
ind_mat<- matrix(NA,nrow=nrow(Fit_model_MCMC),ncol=ncol(Fit_model_MCMC))
for(j in 1:ncol(Fit_model_MCMC)){
ind_mat[,j]<- ifelse(Fit_model_MCMC[,j]< thresholds[th],1,0)
}
pctBelowThreshold<-rowSums(ind_mat)/ncol(ind_mat)
pctBelowThresholds[,th]<- pctBelowThreshold
#print(plot(1:length(pctBelowThreshold),pctBelowThreshold,type="l",ylab=paste0("P(Y<",thresholds[th],"|X<-4.7)"),xlab="step"))
#estimate P(Y < -290 | X< -4.7)
p_hat[th]<- mean(pctBelowThreshold)
#what's the standard deviation of this estimate using the traditional approach
#for calculating the standard devation of a sample proportion, where
# sqrt(n)*(p_hat- p)/ sqrt(p(1-p)) ~ N( 0 , 1 )
sd_p_hat[th]<- sqrt(p_hat[th]*(1-p_hat[th])/length(pctBelowThreshold))
#now use the batchmeans package to estimate the
#mean and standard error
bm_est[th]<- bm(pctBelowThreshold)$est
bm_se[th]<- bm(pctBelowThreshold)$se
}
print(bm_est) #monte carlo estimate of P(Y<threshold | X< -4.7) for each threshold
print(bm_se) #monte carlo standard errors for all thresholds
#how different do the markov chains look for estimating each population proportion?
pdf(file="figures/Workflow_example/PropEstimatesConvergence.pdf",width=8,height=6)
getwd()
pctBelowThresholds[1:5e3,6]
for(i in 1:length(thresholds)){
print(paste0("% below ",thresholds[i]," estimate :",as.numeric(bm_est[i])))
print(paste0("% below ",thresholds[i]," estimate MCSE :",as.numeric(bm_se[i])))
}
for(i in 1:length(thresholds)){
print(paste0("% below ",thresholds[i]," MCSE/estimate :", as.numeric(bm_se[i])/as.numeric(bm_est[i])))
}
for(i in 1:length(thresholds)){
print(paste0("% below ",thresholds[i]," estimate :", as.numeric(bm_est[i])))
print(paste0("% below ",thresholds[i]," MCSE :", as.numeric(bm_se[i])))
}
for(i in 1:length(thresholds)){
print(paste0("% below ",thresholds[i]," estimate :", as.numeric(bm_est[i])))
}
#estimating a population proportion with mcmc
library(batchmeans)
#mcmc.chains<- mcmc.chains[-(1:30000),]
thresholds<- seq(-210,-290,by=-10)
bm_est<- rep(NA,length(thresholds))
bm_se<- rep(NA,length(thresholds))
p_hat<- rep(NA,length(thresholds))
sd_p_hat<- rep(NA,length(thresholds))
badXinds<- which(X< -4.7)
pctBelowThresholds<- matrix(NA,nrow=nrow(mcmc.chains),
ncol=length(thresholds))
for(th in 1:length(thresholds)){
Fit_model_MCMC<- mat.or.vec(nrow(mcmc.chains), length(badXinds))
for(j in 1:nrow(mcmc.chains)){
for (i in badXinds){
Fit_model_MCMC[j,i] <- Y(mcmc.chains[j,1],
mcmc.chains[j,2],X[i])+
rnorm(1,mean=0,sd=sigma_obs)
}
}
ind_mat<- matrix(NA,nrow=nrow(Fit_model_MCMC),ncol=ncol(Fit_model_MCMC))
for(j in 1:ncol(Fit_model_MCMC)){
ind_mat[,j]<- ifelse(Fit_model_MCMC[,j]< thresholds[th],1,0)
}
pctBelowThreshold<-rowSums(ind_mat)/ncol(ind_mat)
pctBelowThresholds[,th]<- pctBelowThreshold
#print(plot(1:length(pctBelowThreshold),pctBelowThreshold,type="l",ylab=paste0("P(Y<",thresholds[th],"|X<-4.7)"),xlab="step"))
#estimate P(Y < -290 | X< -4.7)
p_hat[th]<- mean(pctBelowThreshold)
#what's the standard deviation of this estimate using the traditional approach
#for calculating the standard devation of a sample proportion, where
# sqrt(n)*(p_hat- p)/ sqrt(p(1-p)) ~ N( 0 , 1 )
sd_p_hat[th]<- sqrt(p_hat[th]*(1-p_hat[th])/length(pctBelowThreshold))
#now use the batchmeans package to estimate the
#mean and standard error
bm_est[th]<- bm(pctBelowThreshold)$est
bm_se[th]<- bm(pctBelowThreshold)$se
}
for(i in 1:length(thresholds)){
print(paste0("% below ",thresholds[i]," estimate :", as.numeric(bm_est[i])))
}
for(i in 1:length(thresholds)){
print(paste0("% below ",thresholds[i]," MCSE :", as.numeric(bm_se[i])))
}
for(i in 1:length(thresholds)){
print(paste0("% below ",thresholds[i]," MCSE/estimate :", as.numeric(bm_se[i])/as.numeric(bm_est[i])))
}
#the ratio of the MCSE to the estimated proportion increases as the threshold decreases
plot(1:length(pctBelowThresholds[,2]),pctBelowThresholds[,2],
type="l", col= "orange", ylim=c(0,1),
ylab=paste0("P(Y<y|X<-4.7)"),xlab="step")
#lines(1:length(pctBelowThresholds[,3]),pctBelowThresholds[,3],type="l",col="red")
lines(1:length(pctBelowThresholds[,6]),pctBelowThresholds[,6],type="l",col="purple")
#lines(1:length(pctBelowThresholds[,7]),pctBelowThresholds[,7],type="l",col="blue")
lines(1:length(pctBelowThresholds[,10]),pctBelowThresholds[,10],type="l",col="turquoise")
#how different do the markov chains look for estimating each population proportion?
pdf(file="figures/Workflow_example/PropEstimatesConvergence.pdf",width=8,height=6)
plot(1:length(pctBelowThresholds[,1]),pctBelowThresholds[,1],
type="l", col= "orange", ylim=c(0,1),
ylab=paste0("P(Y<y|X<-4.7)"),xlab="step")
#lines(1:length(pctBelowThresholds[,3]),pctBelowThresholds[,3],type="l",col="red")
lines(1:length(pctBelowThresholds[,5]),pctBelowThresholds[,5],type="l",col="purple")
#lines(1:length(pctBelowThresholds[,7]),pctBelowThresholds[,7],type="l",col="blue")
lines(1:length(pctBelowThresholds[,9]),pctBelowThresholds[,9],type="l",col="turquoise")
legend("topright", c(paste0("y=",thresholds[1]),
paste0("y=",thresholds[5]),
paste0("y=",thresholds[9])),
lty=1, lwd = 3, col = c("orange","purple","turquoise"),inset=c(0,-0.25))
#how different do the markov chains look for estimating each population proportion?
pdf(file="compare/figures/Workflow_example/PropEstimatesConvergence.pdf",width=8,height=6)
par(mar=c(5.1, 4.1, 6.1, 2.1), xpd=TRUE)
plot(1:length(pctBelowThresholds[,1]),pctBelowThresholds[,1],
type="l", col= "orange", ylim=c(0,1),
ylab=paste0("P(Y<y|X<-4.7)"),xlab="step")
#lines(1:length(pctBelowThresholds[,3]),pctBelowThresholds[,3],type="l",col="red")
lines(1:length(pctBelowThresholds[,5]),pctBelowThresholds[,5],type="l",col="purple")
#lines(1:length(pctBelowThresholds[,7]),pctBelowThresholds[,7],type="l",col="blue")
lines(1:length(pctBelowThresholds[,9]),pctBelowThresholds[,9],type="l",col="turquoise")
legend("topright", c(paste0("y=",thresholds[1]),
paste0("y=",thresholds[5]),
paste0("y=",thresholds[9])),
lty=1, lwd = 3, col = c("orange","purple","turquoise"),inset=c(0,-0.25))
dev.off()
pdf(file="compare/figures/Workflow_example/PropEstimatesTraceplots.pdf",width=8,height=6)
par(mar=c(5.1, 4.1, 6.1, 2.1), xpd=TRUE)
plot(1:length(pctBelowThresholds[,1]),pctBelowThresholds[,1],
type="l", col= "orange", ylim=c(0,1),
ylab=paste0("P(Y<y|X<-4.7)"),xlab="step")
#lines(1:length(pctBelowThresholds[,3]),pctBelowThresholds[,3],type="l",col="red")
lines(1:length(pctBelowThresholds[,5]),pctBelowThresholds[,5],type="l",col="purple")
#lines(1:length(pctBelowThresholds[,7]),pctBelowThresholds[,7],type="l",col="blue")
lines(1:length(pctBelowThresholds[,9]),pctBelowThresholds[,9],type="l",col="turquoise")
legend("topright", c(paste0("y=",thresholds[1]),
paste0("y=",thresholds[5]),
paste0("y=",thresholds[9])),
lty=1, lwd = 3, col = c("orange","purple","turquoise"),inset=c(0,-0.25))
dev.off()
pdf(file="compare/figures/Workflow_example/PropEstimatesTraceplotsFirst5k.pdf",width=8,height=6)
par(mar=c(5.1, 4.1, 6.1, 2.1), xpd=TRUE)
plot(1:length(pctBelowThresholds[1:5e3,2]),pctBelowThresholds[1:5e3,2],
type="l", col= "orange", ylim=c(0,1),
ylab=paste0("P(Y<y|X<-4.7)"),xlab="step")
#lines(1:length(pctBelowThresholds[,3]),pctBelowThresholds[,3],type="l",col="red")
lines(1:length(pctBelowThresholds[1:5e3,6]),pctBelowThresholds[1:5e3,6],type="l",col="purple")
#lines(1:length(pctBelowThresholds[,7]),pctBelowThresholds[,7],type="l",col="blue")
lines(1:length(pctBelowThresholds[1:5e3,10]),pctBelowThresholds[1:5e3,10],type="l",col="turquoise")
#how early do the markov chains for estimating each population proportion converge?
pdf(file="compare/figures/Workflow_example/PropEstimatesTraceplotsFirst5k.pdf",width=8,height=6)
par(mar=c(5.1, 4.1, 6.1, 2.1), xpd=TRUE)
plot(1:length(pctBelowThresholds[1:5e3,1]),pctBelowThresholds[1:5e3,1],
type="l", col= "orange", ylim=c(0,1),
ylab=paste0("P(Y<y|X<-4.7)"),xlab="step")
#lines(1:length(pctBelowThresholds[,3]),pctBelowThresholds[,3],type="l",col="red")
lines(1:length(pctBelowThresholds[1:5e3,5]),pctBelowThresholds[1:5e3,5],type="l",col="purple")
#lines(1:length(pctBelowThresholds[,7]),pctBelowThresholds[,7],type="l",col="blue")
lines(1:length(pctBelowThresholds[1:5e3,9]),pctBelowThresholds[1:5e3,9],type="l",col="turquoise")
legend("topright", c(paste0("y=",thresholds[1]),
paste0("y=",thresholds[5]),
paste0("y=",thresholds[9])),
lty=1, lwd = 3, col = c("orange","purple","turquoise"),inset=c(0,-0.25))
dev.off()
plot(1:length(pctBelowThresholds[1:5e3,1]),pctBelowThresholds[1:5e3,1],
type="l", col= "orange", ylim=c(0,1),
ylab=paste0("P(Y<y|X<-4.7)"),xlab="step")
#lines(1:length(pctBelowThresholds[,3]),pctBelowThresholds[,3],type="l",col="red")
lines(1:length(pctBelowThresholds[1:5e3,5]),pctBelowThresholds[1:5e3,5],type="l",col="purple")
#lines(1:length(pctBelowThresholds[,7]),pctBelowThresholds[,7],type="l",col="blue")
lines(1:length(pctBelowThresholds[1:5e3,9]),pctBelowThresholds[1:5e3,9],type="l",col="turquoise")
legend("topright", c(paste0("y=",thresholds[1]),
paste0("y=",thresholds[5]),
paste0("y=",thresholds[9])),
lty=1, lwd = 3, col = c("orange","purple","turquoise"),inset=c(0,-0.25))
pdf(file="compare/figures/Workflow_example/Threshold_vs_PctBelowThreshold.pdf",width=6,height=5)
plot(thresholds,bm_est,
ylab="Estimated P(Y< y|X < -4.7)",
xlab="y")
dev.off()
plot(thresholds,bm_est,
ylab="Estimated P(Y< y|X < -4.7)",
xlab="y")
# How does the monte carlo standard error change with the population proportion estimate?
pdf(file="compare/figures/Workflow_example/PctBelowThreshold_vs_MCSE.pdf",width=6,height=5)
plot(bm_est,bm_se,
ylab="Monte Carlo Standard Error",
xlab="Estimated P(Y< y|X < -4.7)")
dev.off()
plot(bm_est,bm_se,
ylab="Monte Carlo Standard Error",
xlab="Estimated P(Y< y|X < -4.7)")
# How does the monte carlo standard error change with the threshold?
pdf(file="compare/figures/Workflow_example/Threshold_vs_MCSE.pdf",width=6,height=5)
plot(thresholds,bm_se,
ylab="Monte Carlo Standard Error",
xlab="y")
dev.off()
plot(thresholds,bm_se,
ylab="Monte Carlo Standard Error",
xlab="y")
pdf(file="compare/figures/Workflow_example/overlaid_densities_second5k_vs_first10k_-210.pdf")
plot(density(pctBelowThresholds[5e3:1e4,1]),main="",
xlab =paste0("P(Y<",thresholds[1],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:1e4,1]),col = "purple",lwd=3)
legend("topright", c("second 5k","first 10k"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
#overlay density plots for first 10k steps vs second 5k steps
#for threshold= -250
pdf(file="compare/figures/Workflow_example/overlaid_densities_second5k_vs_first10k_-250.pdf")
plot(density(pctBelowThresholds[5e3:1e4,5]),main="",
xlab =paste0("P(Y<",thresholds[5],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:1e4,5]),col = "purple",lwd=3)
legend("topright", c("second 5k","first 10k"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
#overlay density plots for first 10k steps vs second 5k steps
#for threshold= -290
pdf(file="compare/figures/Workflow_example/overlaid_densities_second5k_vs_first10k_-290.pdf")
plot(density(pctBelowThresholds[5e3:1e4,9]),main="",
xlab =paste0("P(Y<",thresholds[9],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:1e4,9]),col = "purple",lwd=3)
legend("topright", c("second 5k","first 10k"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
plot(density(pctBelowThresholds[5e3:1e4,1]),main="",
xlab =paste0("P(Y<",thresholds[1],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:1e4,1]),col = "purple",lwd=3)
legend("topright", c("second 5k","first 10k"),
lty=1, lwd = 3, col = c("turquoise","purple"))
plot(density(pctBelowThresholds[5e3:1e4,5]),main="",
xlab =paste0("P(Y<",thresholds[5],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:1e4,5]),col = "purple",lwd=3)
legend("topright", c("second 5k","first 10k"),
lty=1, lwd = 3, col = c("turquoise","purple"))
plot(density(pctBelowThresholds[5e3:1e4,9]),main="",
xlab =paste0("P(Y<",thresholds[9],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:1e4,9]),col = "purple",lwd=3)
legend("topright", c("second 5k","first 10k"),
lty=1, lwd = 3, col = c("turquoise","purple"))
#does it look like 130k is enough steps?
pdf(file="compare/figures/Workflow_example/overlaid_densities_half1_vs_all_-210.pdf")
plot(density(pctBelowThresholds[(NI/2+1):NI,1]),main="",
xlab =paste0("P(Y<",thresholds[1],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:NI,1]),col = "purple",lwd=3)
legend("topright", c("second half","all"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
pdf(file="compare/figures/Workflow_example/overlaid_densities_half1_vs_all_-250.pdf")
plot(density(pctBelowThresholds[(NI/2+1):NI,5]),main="",
xlab =paste0("P(Y<",thresholds[5],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:NI,5]),col = "purple",lwd=3)
legend("topright", c("second half","all"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
pdf(file="compare/figures/Workflow_example/overlaid_densities_half1_vs_all_-290.pdf")
plot(density(pctBelowThresholds[(NI/2+1):NI,9]),main="",
xlab =paste0("P(Y<",thresholds[9],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:NI,9]),col = "purple",lwd=3)
legend("topright", c("second half","all"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
#overlay density plots for all steps vs second half of steps
#for threshold= -210
pdf(file="compare/figures/Workflow_example/overlaid_densities_half1_vs_all_-210.pdf")
plot(density(pctBelowThresholds[(NI/2+1):NI,1]),main="",
xlab =paste0("P(Y<",thresholds[1],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:NI,1]),col = "purple",lwd=3)
legend("topright", c("second half","all"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
#overlay density plots for all steps vs second half of steps
#for threshold= -250
pdf(file="compare/figures/Workflow_example/overlaid_densities_half1_vs_all_-250.pdf")
plot(density(pctBelowThresholds[(NI/2+1):NI,5]),main="",
xlab =paste0("P(Y<",thresholds[5],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:NI,5]),col = "purple",lwd=3)
legend("topright", c("second half","all"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
#overlay density plots for all steps vs second half of steps
#for threshold= -290
pdf(file="compare/figures/Workflow_example/overlaid_densities_half1_vs_all_-290.pdf")
plot(density(pctBelowThresholds[(NI/2+1):NI,9]),main="",
xlab =paste0("P(Y<",thresholds[9],"|X<-4.7)"),
col = "turquoise",lwd=3)
lines(density(pctBelowThresholds[1:NI,9]),col = "purple",lwd=3)
legend("topright", c("second half","all"),
lty=1, lwd = 3, col = c("turquoise","purple"))
dev.off()
#compare the rounded uncertainty bounds to the estimate for each significant figure
z <- 1.96
interval <- matrix(data = NA, nrow = length(thresholds), ncol = 2)
rownames(interval)<- thresholds
colnames(interval)<- c("lower_bound", "upper_bound")
for(i in 1:length(thresholds)){
z[i] <- (mean(pctBelowThresholds[,i]) - bm_est[i])/bm_se[i]
half_width <- z * bm_se[i ]
interval[i,1] <- bm_est[i] - half_width
interval[i,2] <- bm_est[i] + half_width
}
for(i in 1:length(thresholds)){
print(paste0("% below ",thresholds[i]," estimate :",as.numeric(bm_est[i,1])))
print(paste0("% below ",thresholds[i]," 95% confidence interval :",as.numeric(interval[i,1]),",",as.numeric(interval[i,2])))
}
z <- 1.96
interval <- matrix(data = NA, nrow = length(thresholds), ncol = 2)
rownames(interval)<- thresholds
colnames(interval)<- c("lower_bound", "upper_bound")
for(i in 1:length(thresholds)){
z[i] <- (mean(pctBelowThresholds[,i]) - bm_est[i])/bm_se[i]
half_width <- z * bm_se[i ]
interval[i,1] <- bm_est[i] - half_width
interval[i,2] <- bm_est[i] + half_width
}
z <- 1.96
interval <- matrix(data = NA, nrow = length(thresholds), ncol = 2)
rownames(interval)<- thresholds
colnames(interval)<- c("lower_bound", "upper_bound")
for(i in 1:length(thresholds)){
half_width <- z * bm_se[i ]
interval[i,1] <- bm_est[i] - half_width
interval[i,2] <- bm_est[i] + half_width
}
View(interval)
for(i in 1:length(thresholds)){
print(paste0("% below ",thresholds[i]," estimate :",as.numeric(bm_est[i,1])))
print(paste0("% below ",thresholds[i]," 95% confidence interval :",as.numeric(interval[i,1]),",",as.numeric(interval[i,2])))
}
for(i in 1:length(thresholds)){
print(paste0("% below ",thresholds[i]," estimate :",as.numeric(bm_est[i])))
print(paste0("% below ",thresholds[i]," 95% confidence interval :",as.numeric(interval[i,1]),",",as.numeric(interval[i,2])))
}
